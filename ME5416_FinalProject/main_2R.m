clear; clc;
%% Load parameters from file
run("examples\RR_robot.m")
run("kinematics.m")

%% ode45 calculation
t_end = 30; dt = 0.05;
addpath('param');

[t,Y] = ode45(@(t,y)odefcn(t,y), 0:dt:t_end, [q0; dq0]);

%% Plot graphs
figure
subplot(1,2,1)
q_vect = Y(:,1:n);
plot(t, q_vect) 
title('RR robot'), grid on
xlabel('t, sec'), ylabel('q_i(t), deg'), xlim([0 t_end])
labels = [];
for i = 1:n
    labels = [labels; strcat('q_', num2str(i), '(t)')];
end
legend(cellstr(labels))

subplot(1,2,2)
X_ee = zeros(length(q_vect), 3);
for i=1:length(q_vect)
    X_ee(i,:) = get_X_ee(q_vect(i,:)');
end
plot(t, X_ee)
title('End-effector position'), grid on
xlabel('t, sec'), ylabel('Position, m'), xlim([0 t_end])
legend('X_{ee}(1)', 'X_{ee}(2)', 'X_{ee}(3)')

manip_animation(q,q_vect,Tr,dt);

%% inverse kinematics (IK)
function q_desired = get_inverse_kinematics(X_ee_desired)
    % input: 
    %   X_ee_desired - desired [x; y; z] for effector，in that case only x&&z are efective
    % output: 
    %   q_desired - joint angle [q1; q2]
    % link length which have been defined in RR_robot.m
    l1 = 1;
    l2 = 1;
    % robot arm operates in the X-Z plane and takes the x and z components
    x_d = X_ee_desired(1);
    z_d = X_ee_desired(3);
    % distance from the target point to the origin
    r = sqrt(x_d^2 + z_d^2);
    % check if target in work space
    if r > (l1 + l2)
        error('The target out of range!!!');
    end
    % computing q2 (Cosine Theorem)
    cos_q2 = (r^2 - l1^2 - l2^2) / (2 * l1 * l2);
    % make sure cos_q2∈[-1, 1]
    cos_q2 = max(min(cos_q2, 1), -1);
    q2 = acos(cos_q2);
    % computing q1
    % using elbow-down solution
    q1 = atan2(z_d, x_d) - atan2(l2 * sin(q2), l1 + l2 * cos(q2));
    
    q_desired = [q1; q2];
end

%% Control
function dx = odefcn(t, x)
    % x = [q; dq]
    n = numel(x)/2;
    q  = x(1:n);
    dq = x(n+1:end);

    % IK method
    % task1: cyclic motion in Z-axis
%     q_desired = get_inverse_kinematics([0; 0; 2 * sin(2*pi*t/30)]);
    % task2: cyclic motion in X-Z plane
    q_desired = get_inverse_kinematics([1 * cos(2*pi*t/30); 0; 1 * cos(2*pi*t/30)]);
    
    % Joint space PD control
    Kp_joint = 2000;  % Position gain
    Kd_joint = 200;   % Velocity gain
    tau = -Kp_joint * (q - q_desired) - Kd_joint * dq;
    
    % geting param.
    M = get_M(q);
    C = get_C([q; dq]);
    D = get_D([q; dq]);
    g_val = get_g(q);
    
    % Dynamic state space model
    A_dyn = [zeros(n), eye(n);
             zeros(n), -inv(M) * (C + D)];
    B_dyn = [zeros(n); inv(M)];
    
    % control input: joint torque generated by gravity compensation + PD control
    u = -g_val + tau;
    
    dx = A_dyn * x + B_dyn * u;
end
