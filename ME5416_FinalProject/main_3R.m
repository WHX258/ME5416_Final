clear; clc;
%% Load parameters from file
run("examples\RRR_robot.m");
run("kinematics.m");

%% ode45 calculation
tau = zeros(n,1);
h_e = [0;0;0];
t_end = 10; dt = 0.05;
addpath('param');
[t,Y] = ode45(@(t,y)odefcn(t,y,tau,h_e), 0:dt:t_end, [q0; dq0]);

%% Plot graphs
figure
subplot(1,2,1)
q_vect = Y(:,1:n);
plot(t, q_vect) 
title('RRR robot'), grid on
xlabel('t, sec'), ylabel('q_i(t), deg'), xlim([0 t_end])
labels = [];
for i = 1:n
    labels = [labels; strcat('q_', num2str(i), '(t)')];
end
legend(cellstr(labels))

subplot(1,2,2)
X_ee = zeros(length(q_vect), 3);
for i=1:length(q_vect)
    X_ee(i,:) = get_X_ee(q_vect(i,:)');
end
plot(t, X_ee)
title('End-effector position'), grid on
xlabel('t, sec'), ylabel('Position, m'), xlim([0 t_end])
legend('X_{ee}(1)', 'X_{ee}(2)', 'X_{ee}(3)')

manip_animation(q,q_vect,Tr,dt);
%% inverse kinematics (IK)
function q = get_inverse_kinematics(Xee)
    % input：
    %   Xee - desired [x; y; z]
    % output：
    %   q - [q1; q2; q3] 3 joint angles
    x = Xee(1);
    y = Xee(2);
    z = Xee(3);
    % q1 control arm rotates around Z-axis
    q1 = atan2(y, x);

    x1 = sqrt(x^2 + y^2);  % x' = projection to new X axis
    z1 = z;
    l1 = 1;
    l2 = 1;
    % distance from operator to 0 point
    r = sqrt(x1^2 + z1^2);
    % Check reachability
    if r > (l1+l2)
        error('The target out of range!!!');
    end
    % like 2R, compute q2 and q3
    cos_q3 = (r^2 - l1^2 - l2^2) / (2 * l1 * l2);
    cos_q3 = max(min(cos_q3, 1), -1);  
    q3 = acos(cos_q3);  % elbow-down solution

    phi = atan2(z1, x1);
    psi = atan2(l2*sin(q3), l1 + l2*cos(q3));
    q2 = phi - psi;
    q = [q1; q2; q3];
end

%% Control
function dx = odefcn(t, x,~,~)
    % x = [q; dq]
    n = numel(x)/2;
    q  = x(1:n);
    dq = x(n+1:end);
    
    % computing q by IK method
%     % task0: reach a fixed point
%     q_desired = get_inverse_kinematics([1.1;1.1;1.1]);
% %     task1: cyclic motion in Z-axis
%     q_desired = get_inverse_kinematics([0; 0; 2 * sin(2*pi*t/10)]);
%     % task2: cyclic motion in Y-axis
%     q_desired = get_inverse_kinematics([0; 2 * sin(2*pi*t/30); 0]);
%     % task3: cyclic motion in X-axis
%     q_desired = get_inverse_kinematics([2 * sin(2*pi*t/30); 0; 0]);
    % task4: cyclic motion in a aline
    q_desired = get_inverse_kinematics([1 * sin(2*pi*t/10); 1 * sin(2*pi*t/10); 1 * sin(2*pi*t/10)]);

    % control method (PID)
    Kp_joint = 300;  % Position gain
    Kd_joint = 80;   % Velocity gain
    tau = -Kp_joint * (q - q_desired) - Kd_joint * dq;
    
    % geting param.
    M = get_M(q);
    C = get_C([q; dq]);
    D = get_D([q; dq]);
    g_val = get_g(q);
    
    % Dynamic state space model
    A_dyn = [zeros(n), eye(n);
             zeros(n), -inv(M) * (C + D)];
    B_dyn = [zeros(n); inv(M)];
    
    % control input: joint torque generated by gravity compensation + PD control
    u = -g_val + tau;
    
    dx = A_dyn * x + B_dyn * u;
end
